Love the direction. I reworked sensors with a big focus on Motion drawing, added multiple sensor modes, stabilized tilt (no more feedback loop), fixed the random long lines by gating teleport segments, and added more controls (deadzone, friction, min-draw speed, filter strength, bounds, linear-acc toggle, calibrate, center). Motion modes now paint without touch as requested.

Copy this whole file into an .html and open on your phone.

```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
<title>Psychedelic Sketch ‚Äî Sensor Lab</title>
<style>
  :root {
    --bg: #050508;
    --panel: rgba(15,15,20,0.86);
    --text: #eaeaf3;
    --muted: #9aa1b2;
    --accent: #8bf7ff;
    --accent-2: #ff8bf7;
    --btn: rgba(255,255,255,0.08);
    --btn-hover: rgba(255,255,255,0.16);
    --shadow: 0 10px 30px rgba(0,0,0,0.45);
  }
  html, body {
    margin: 0;
    padding: 0;
    background: var(--bg);
    color: var(--text);
    height: 100%;
    overflow: hidden;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji;
    -webkit-touch-callout: none;
    -webkit-tap-highlight-color: transparent;
  }
  #app {
    position: fixed;
    inset: 0;
    display: grid;
    grid-template-rows: auto 1fr auto;
  }
  canvas {
    position: absolute;
    inset: 0;
    width: 100vw;
    height: 100vh;
    touch-action: none;
    display: block;
    background:
      radial-gradient(1200px 800px at 45% 40%, rgba(50,10,60,0.18), transparent 60%),
      radial-gradient(900px 600px at 65% 60%, rgba(10,60,60,0.14), transparent 60%),
      var(--bg);
  }
  /* Top bar */
  .topbar {
    position: fixed;
    top: env(safe-area-inset-top, 8px);
    left: 0; right: 0;
    display: flex; align-items: center; justify-content: space-between;
    padding: 8px 10px;
    pointer-events: none;
    z-index: 10;
  }
  .btn {
    pointer-events: all;
    display: inline-flex; align-items: center; justify-content: center;
    gap: 8px;
    background: var(--btn);
    color: var(--text);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 12px;
    padding: 10px 12px;
    font-size: 14px; line-height: 1;
    box-shadow: var(--shadow);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    user-select: none;
  }
  .btn:active { transform: translateY(1px); }
  .btn.active { outline: 2px solid var(--accent); }
  .icon { font-size: 18px; }
  .chip {
    pointer-events: all;
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.08);
    color: var(--muted);
    border-radius: 999px;
    padding: 8px 12px;
    font-size: 12px;
    box-shadow: var(--shadow);
    backdrop-filter: blur(6px);
  }
  /* Settings panel */
  #panel {
    position: fixed;
    left: 10px; right: 10px;
    top: calc(env(safe-area-inset-top, 8px) + 54px);
    max-width: 1100px;
    margin: 0 auto;
    background: var(--panel);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 16px;
    padding: 12px;
    box-shadow: var(--shadow);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    transform-origin: top center;
    transition: transform 200ms ease, opacity 200ms ease;
    z-index: 11;
  }
  #panel.hidden { transform: scale(0.98); opacity: 0; pointer-events: none; }
  .grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
  }
  @media (min-width: 720px) {
    .grid { grid-template-columns: repeat(3, 1fr); }
  }
  @media (min-width: 1080px) {
    .grid { grid-template-columns: repeat(4, 1fr); }
  }
  .control {
    display: grid;
    gap: 6px;
    background: rgba(255,255,255,0.04);
    padding: 8px;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.08);
  }
  .control label {
    display: flex; align-items: center; justify-content: space-between;
    font-size: 12px; color: var(--muted);
  }
  .control input[type="range"],
  .control select {
    width: 100%;
    accent-color: var(--accent);
  }
  .row {
    display: flex; gap: 8px; flex-wrap: wrap;
  }
  .pill {
    flex: 1 1 auto; text-align: center;
  }
  .pill.active { outline: 2px solid var(--accent); }
  /* Bottom bar */
  .bottombar {
    position: fixed;
    bottom: calc(env(safe-area-inset-bottom, 8px) + 8px);
    left: 0; right: 0;
    display: flex; gap: 10px; justify-content: center;
    z-index: 10;
  }
  .fab {
    pointer-events: all;
    background: linear-gradient(135deg, var(--accent), var(--accent-2));
    color: #020206;
    border: none;
    border-radius: 14px;
    padding: 12px 16px;
    font-weight: 700;
    box-shadow: 0 10px 30px rgba(139,247,255,0.35), 0 10px 30px rgba(255,139,247,0.25);
    user-select: none;
  }
  .fab.secondary {
    background: var(--btn);
    color: var(--text);
    border: 1px solid rgba(255,255,255,0.08);
    box-shadow: var(--shadow);
  }
  .legend {
    position: fixed;
    left: 50%; transform: translateX(-50%);
    bottom: calc(env(safe-area-inset-bottom, 8px) + 60px);
    font-size: 12px; color: var(--muted);
    text-align: center; padding: 6px 10px;
    background: rgba(0,0,0,0.35);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 10px; backdrop-filter: blur(8px);
    z-index: 9;
  }
</style>
</head>
<body>
<div id="app">
  <canvas id="c"></canvas>

  <div class="topbar">
    <button id="menuBtn" class="btn" aria-label="Settings"><span class="icon">‚öôÔ∏è</span> Settings</button>
    <div class="chip" id="hint">enable Sensors ‚Üí Motion modes to draw by moving the phone</div>
    <div style="display:flex; gap:8px;">
      <button id="sensorBtn" class="btn" aria-label="Enable sensors"><span class="icon">üì≥</span> Sensors</button>
      <button id="saveBtn" class="btn" aria-label="Save"><span class="icon">üì∏</span></button>
    </div>
  </div>

  <div id="panel" class="hidden">
    <div class="grid">
      <div class="control">
        <label>Palette
          <select id="palette">
            <option>Rainbow</option>
            <option>Neon</option>
            <option>Sunset</option>
            <option>Ocean</option>
            <option>Acid</option>
          </select>
        </label>
        <label>Color speed <span id="colorSpeedVal"></span></label>
        <input type="range" id="colorSpeed" min="0" max="1.2" step="0.01" value="0.48" />
      </div>

      <div class="control">
        <label>Brush size <span id="sizeVal"></span></label>
        <input type="range" id="size" min="1" max="100" step="1" value="30" />
        <label>Glow <span id="glowVal"></span></label>
        <input type="range" id="glow" min="0" max="70" step="1" value="26" />
        <div class="row">
          <button id="brushSoft" class="btn pill active">Soft</button>
          <button id="brushSpray" class="btn pill">Spray</button>
        </div>
      </div>

      <div class="control">
        <label>Symmetry slices <span id="symVal"></span></label>
        <input type="range" id="sym" min="1" max="24" step="1" value="10" />
        <div class="row">
          <button id="mirror" class="btn pill">Mirror</button>
          <button id="kaleido" class="btn pill active">Kaleido</button>
        </div>
      </div>

      <div class="control">
        <label>Trail fade <span id="fadeVal"></span></label>
        <input type="range" id="fade" min="0" max="0.25" step="0.005" value="0.035" />
        <label>Scatter <span id="scatterVal"></span></label>
        <input type="range" id="scatter" min="0" max="1" step="0.01" value="0.2" />
      </div>

      <div class="control">
        <label>Turbulence mode
          <select id="turbMode">
            <option value="off">Off</option>
            <option value="noise">Noise</option>
            <option value="curl" selected>Curl</option>
          </select>
        </label>
        <label>Intensity <span id="turbIntVal"></span></label>
        <input type="range" id="turbInt" min="0" max="1.2" step="0.01" value="0.65" />
        <label>Scale <span id="turbScaleVal"></span></label>
        <input type="range" id="turbScale" min="0.001" max="0.03" step="0.001" value="0.009" />
        <label>Flow speed <span id="turbSpeedVal"></span></label>
        <input type="range" id="turbSpeed" min="0" max="2" step="0.01" value="0.6" />
      </div>

      <div class="control">
        <label>Sensor mode
          <select id="sensorMode">
            <option value="off">Off</option>
            <option value="tilt">Tilt (stable map)</option>
            <option value="motion">Motion (inertial)</option>
            <option value="motion-swirl">Motion + Gyro swirl</option>
            <option value="gyro-orbit">Gyro orbit</option>
          </select>
        </label>
        <label>Sensor influence <span id="sensorInfVal"></span></label>
        <input type="range" id="sensorInf" min="0" max="1" step="0.01" value="0.7" />
        <label>Motion sensitivity <span id="motionSensVal"></span></label>
        <input type="range" id="motionSens" min="0.2" max="3" step="0.05" value="1.2" />
        <label>Friction <span id="frictionVal"></span></label>
        <input type="range" id="friction" min="0.80" max="0.98" step="0.01" value="0.93" />
        <label>Deadzone <span id="deadzoneVal"></span></label>
        <input type="range" id="deadzone" min="0" max="0.3" step="0.01" value="0.06" />
      </div>

      <div class="control">
        <label>Min draw speed <span id="minDrawVal"></span></label>
        <input type="range" id="minDraw" min="0" max="0.5" step="0.01" value="0.08" />
        <label>Filter strength <span id="filterVal"></span></label>
        <input type="range" id="filter" min="0" max="0.95" step="0.01" value="0.7" />
        <label>Bounds
          <select id="boundsMode">
            <option value="wrap" selected>Wrap</option>
            <option value="bounce">Bounce</option>
            <option value="clamp">Clamp</option>
          </select>
        </label>
        <div class="row">
          <button id="useLinear" class="btn pill active">Linear Accel</button>
          <button id="shakeClear" class="btn pill">Shake clears</button>
          <button id="sensorDraw" class="btn pill active">Sensor draws</button>
        </div>
        <div class="row">
          <button id="calibrate" class="btn pill">Calibrate</button>
          <button id="center" class="btn pill">Center Brush</button>
        </div>
      </div>

      <div class="control">
        <label>Background
          <select id="bgMode">
            <option value="dark">Dark</option>
            <option value="deep">Deep Gradient</option>
            <option value="light">Light</option>
          </select>
        </label>
        <div class="row">
          <button id="composite" class="btn pill active">Additive</button>
          <button id="randomize" class="btn pill">Randomize</button>
        </div>
      </div>

      <div class="control">
        <label>Quality
          <select id="quality">
            <option value="performance">Performance</option>
            <option value="balanced" selected>Balanced</option>
            <option value="high">High</option>
          </select>
        </label>
        <div class="row">
          <button id="resetView" class="btn pill">Reset</button>
        </div>
      </div>
    </div>
  </div>

  <div class="legend" id="legend">Motion modes paint without touch ‚Ä¢ tweak sensitivity, deadzone, friction ‚Ä¢ calibrate if tilt feels off</div>

  <div class="bottombar">
    <button id="clearBtn" class="fab secondary">Clear</button>
    <button id="autoBtn" class="fab">Auto</button>
  </div>
</div>

<script>
(function(){
  'use strict';

  // Canvas + DPR setup
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });
  let DPR_MAX = 2;
  let DPR = Math.min(DPR_MAX, window.devicePixelRatio || 1);

  const state = {
    width: 0, height: 0, cx: 0, cy: 0,

    // drawing
    brush: 'soft', // 'soft'|'spray'
    brushSize: 30,
    glow: 26,
    symmetry: 10,
    kaleido: true,
    mirror: false,
    rotOffset: 0,
    palette: 'Rainbow',
    colorSpeed: 0.48,
    colorOffset: Math.random()*360,
    scatter: 0.2,
    fade: 0.035,
    composite: 'lighter',
    bgMode: 'dark',

    // turbulence
    turbMode: 'curl',
    turbInt: 0.65,
    turbScale: 0.009,
    turbSpeed: 0.6,

    // sensors
    sensorsEnabled: false,
    sensorMode: 'off',                 // 'off'|'tilt'|'motion'|'motion-swirl'|'gyro-orbit'
    sensorInf: 0.7,
    motionSens: 1.2,
    friction: 0.93,
    deadzone: 0.06,
    minDrawSpeed: 0.08,
    filterStrength: 0.7,               // 0..0.95 low-pass factor
    boundsMode: 'wrap',                 // 'wrap'|'bounce'|'clamp'
    useLinear: true,
    shakeClears: false,
    sensorDraws: true,

    // orientation + accel
    tiltX: 0, tiltY: 0, yaw: 0, yawBias: 0,
    accelMag: 0,
    ax: 0, ay: 0, az: 0,               // linear accel (filtered)
    gx: 0, gy: 0, gz: 0,               // gravity estimate (LPF)
    rot: { alpha: 0, beta: 0, gamma: 0 }, // deg/s
    rotMag: 0,

    // sensor painter (virtual brush)
    sensor: { x: 0, y: 0, vx: 0, vy: 0, lastX: 0, lastY: 0, inited: false },

    // input pointers
    pointers: new Map(),

    // auto
    auto: false,
    agents: [],

    // perf
    quality: 'balanced',
  };

  // Utils
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const smooth = t => t*t*(3-2*t);

  // Noise (3D value noise for wiggle/flow)
  function hash3(i,j,k){
    const s = Math.sin(i*127.1 + j*311.7 + k*74.7)*43758.5453123;
    return s - Math.floor(s);
  }
  function noise3(x,y,z){
    const i = Math.floor(x), j = Math.floor(y), k = Math.floor(z);
    const fx = x - i, fy = y - j, fz = z - k;
    const u = smooth(fx), v = smooth(fy), w = smooth(fz);
    const n000 = hash3(i, j, k);
    const n100 = hash3(i+1, j, k);
    const n010 = hash3(i, j+1, k);
    const n110 = hash3(i+1, j+1, k);
    const n001 = hash3(i, j, k+1);
    const n101 = hash3(i+1, j, k+1);
    const n011 = hash3(i, j+1, k+1);
    const n111 = hash3(i+1, j+1, k+1);
    const nx00 = lerp(n000, n100, u);
    const nx10 = lerp(n010, n110, u);
    const nx01 = lerp(n001, n101, u);
    const nx11 = lerp(n011, n111, u);
    const nxy0 = lerp(nx00, nx10, v);
    const nxy1 = lerp(nx01, nx11, v);
    return lerp(nxy0, nxy1, w);
  }

  // Turbulence flow vector (noise/curl)
  function flowVec(x, y, t){
    if (state.turbMode === 'off') return { x: 0, y: 0 };
    const s = state.turbScale;
    const z = t * state.turbSpeed;

    // tilt bias for subtle control
    const biasX = state.tiltX * state.sensorInf * 0.6;
    const biasY = -state.tiltY * state.sensorInf * 0.6;

    let fx = 0, fy = 0;
    if (state.turbMode === 'noise'){
      fx = (noise3(x*s + 5.2, y*s + 1.7, z) - 0.5) * 2;
      fy = (noise3(x*s - 7.1, y*s - 3.4, z) - 0.5) * 2;
    } else { // curl
      const eps = 1.0;
      const nx1 = noise3((x+eps)*s, y*s, z);
      const nx2 = noise3((x-eps)*s, y*s, z);
      const ny1 = noise3(x*s, (y+eps)*s, z);
      const ny2 = noise3(x*s, (y-eps)*s, z);
      const dnx = nx1 - nx2;
      const dny = ny1 - ny2;
      fx = dny; fy = -dnx;
    }

    const mag = Math.hypot(fx, fy) || 1;
    fx = fx/mag + biasX;
    fy = fy/mag + biasY;

    // motion burst
    const bump = clamp(state.accelMag*0.015, 0, 2) * state.sensorInf;
    return { x: fx*(1 + bump), y: fy*(1 + bump) };
  }

  // Colors / Palettes
  function hsla(h,s,l,a=1){ return `hsla(${(h%360+360)%360},${s}%,${l}%,${a})`; }
  function getColor(name, t, x, y){
    const base = state.colorOffset + t;
    switch(name){
      case 'Neon':   return hsla(base + (x - state.cx)*0.05, 100, 60 + 10*Math.sin((y + t)*0.01));
      case 'Sunset': return hsla(10 + 30*Math.sin((t + x*0.3)*0.003) + 20*Math.sin((t + y*0.2)*0.002), 95, 55 + 10*Math.sin(t*0.0012));
      case 'Ocean':  return hsla(190 + 40*Math.sin((x+y+t)*0.002), 90, 50 + 10*Math.sin((t + x)*0.001));
      case 'Acid':   return hsla(base*1.1 + 180*Math.sin((x*0.02)+(t*0.003)), 100, 60);
      default:       return hsla(base + 0.06*(x - state.cx) + 0.04*(y - state.cy), 100, 58);
    }
  }

  // Resize
  function resize(preserve=false){
    let prevBitmap = null;
    if (preserve && canvas.transferToImageBitmap){
      try { prevBitmap = canvas.transferToImageBitmap(); } catch(_) {}
    }
    DPR = Math.min(DPR_MAX, window.devicePixelRatio || 1);
    const w = Math.floor(window.innerWidth);
    const h = Math.floor(window.innerHeight);
    canvas.width = Math.floor(w * DPR);
    canvas.height = Math.floor(h * DPR);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    state.width = w; state.height = h;
    state.cx = w/2; state.cy = h/2;
    paintBackground(true);

    // re-center sensor painter if not inited
    if (!state.sensor.inited) {
      state.sensor.x = state.cx; state.sensor.y = state.cy;
      state.sensor.lastX = state.cx; state.sensor.lastY = state.cy;
    }

    if (preserve && prevBitmap){
      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(prevBitmap, 0, 0, w, h);
      ctx.restore();
      prevBitmap.close?.();
    }
  }
  window.addEventListener('resize', () => resize(true), { passive: true });

  function paintBackground(hard=false){
    ctx.save();
    ctx.setTransform(DPR,0,0,DPR,0,0);
    if (hard) ctx.clearRect(0,0,state.width,state.height);
    if (state.bgMode === 'light'){
      ctx.fillStyle = 'rgba(250,252,255,1)';
      ctx.fillRect(0,0,state.width,state.height);
    } else if (state.bgMode === 'deep'){
      const g = ctx.createRadialGradient(state.cx, state.cy, Math.min(state.width,state.height)*0.1, state.cx, state.cy, Math.max(state.width,state.height));
      g.addColorStop(0, 'rgba(10,10,20,1)');
      g.addColorStop(1, 'rgba(0,0,0,1)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,state.width,state.height);
    } else {
      ctx.fillStyle = 'rgba(5,5,8,1)';
      ctx.fillRect(0,0,state.width,state.height);
    }
    ctx.restore();
  }

  // Pointer input (manual drawing)
  function onDown(e){
    e.preventDefault();
    canvas.setPointerCapture?.(e.pointerId);
    state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY, t: performance.now(), pressure: e.pressure ?? 0.6 });
  }
  function onMove(e){
    const prev = state.pointers.get(e.pointerId);
    if (!prev) return;
    const now = { x: e.clientX, y: e.clientY, t: performance.now(), pressure: e.pressure ?? 0.6 };
    safeSymmetricSegment(prev, now);
    state.pointers.set(e.pointerId, now);
  }
  function onUp(e){
    state.pointers.delete(e.pointerId);
  }
  canvas.addEventListener('pointerdown', onDown, { passive: false });
  canvas.addEventListener('pointermove', onMove, { passive: false });
  canvas.addEventListener('pointerup', onUp, { passive: false });
  canvas.addEventListener('pointercancel', onUp, { passive: false });
  canvas.addEventListener('pointerleave', onUp, { passive: false });

  // Symmetry helpers
  function rotateAround(x,y, cx,cy, ang){
    const dx = x - cx, dy = y - cy;
    const cos = Math.cos(ang), sin = Math.sin(ang);
    return { x: cx + dx*cos - dy*sin, y: cy + dx*sin + dy*cos };
  }
  function mirrorAcrossCenter(x,y){
    const dx = x - state.cx;
    return { x: state.cx - dx, y };
  }
  function reflectAcrossAxis(p, ang){
    const dx = p.x - state.cx, dy = p.y - state.cy;
    const ux = Math.cos(ang), uy = Math.sin(ang);
    const dot = dx*ux + dy*uy;
    const rx = 2*dot*ux - dx;
    const ry = 2*dot*uy - dy;
    return { x: state.cx + rx, y: state.cy + ry };
  }

  // Teleport/long-segment guard to prevent random long lines
  function safeSymmetricSegment(a, b){
    const dt = Math.abs((b.t||0) - (a.t||0)) || 0;
    const dist = Math.hypot((b.x-a.x), (b.y-a.y));
    const MAX_SEG = Math.min(state.width, state.height) * 0.35;
    if (dt > 180 || dist > MAX_SEG){
      // treat as teleport; update last but don't draw
      return;
    }
    drawSymmetricSegment(a, b);
  }

  function drawSymmetricSegment(a, b){
    const slices = Math.max(1, Math.floor(state.symmetry));
    const angleStep = (Math.PI*2) / slices;
    const rotOff = state.rotOffset;

    for (let i=0; i<slices; i++){
      const ang = i * angleStep + rotOff;
      const ra = rotateAround(a.x, a.y, state.cx, state.cy, ang);
      const rb = rotateAround(b.x, b.y, state.cx, state.cy, ang);
      drawOrganicSegment(ra, rb);

      if (state.kaleido){
        const ka = reflectAcrossAxis(ra, ang);
        const kb = reflectAcrossAxis(rb, ang);
        drawOrganicSegment(ka, kb);
      }
      if (state.mirror){
        const ma = mirrorAcrossCenter(ra.x, ra.y);
        const mb = mirrorAcrossCenter(rb.x, rb.y);
        drawOrganicSegment(ma, mb);
      }
    }
  }

  function drawOrganicSegment(a, b){
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const dist = Math.hypot(dx, dy);
    if (dist < 0.5) return;

    const tNow = performance.now();
    const stepBase = Math.max(1, state.brushSize * 0.32);
    const steps = Math.max(1, Math.floor(dist / Math.max(1, stepBase)));
    const nx = -dy / dist, ny = dx / dist;

    ctx.save();
    ctx.globalCompositeOperation = state.composite;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.shadowBlur = state.glow;
    ctx.globalAlpha = 0.95;

    for (let i=0; i<=steps; i++){
      const f = i/steps;
      let x = lerp(a.x, b.x, f);
      let y = lerp(a.y, b.y, f);

      // Turbulence warp
      if (state.turbMode !== 'off' && state.turbInt > 0){
        const fv = flowVec(x, y, tNow*0.001);
        const warp = state.turbInt * (0.8 + 0.6*Math.abs(Math.sin((tNow*0.002)+(i*0.3))));
        x += fv.x * warp * (6 + state.brushSize*0.2);
        y += fv.y * warp * (6 + state.brushSize*0.2);
      }

      // Organic wiggle + sensor tilt on normal
      const nval = (noise3(x*0.015, y*0.015, tNow*0.001) - 0.5) * 2;
      const tiltW = (state.tiltX + state.tiltY)*0.5;
      const wiggle = (state.scatter*12 + state.brushSize*0.12) * (nval + tiltW*state.sensorInf*0.6);
      x += nx * wiggle;
      y += ny * wiggle;

      const pressure = state.pointers.size ? [...state.pointers.values()][0]?.pressure || 0.7 : 0.7;
      const accelBoost = (state.accelMag * 0.03) * state.sensorInf;
      const size = Math.max(1, state.brushSize * (0.6 + 0.4*Math.abs(nval)) * (0.85 + accelBoost) * (0.6 + 0.7*pressure));
      const hueShift = dist * state.colorSpeed * 0.3 + i * state.colorSpeed * 1.1 + ((state.yaw - state.yawBias)*15*state.sensorInf);
      const col = getColor(state.palette, state.colorOffset + hueShift, x, y);

      ctx.shadowColor = col;
      ctx.fillStyle = col;

      if (state.brush === 'soft'){
        ctx.beginPath();
        ctx.arc(x, y, size*0.5, 0, Math.PI*2);
        ctx.fill();
      } else {
        const sprayCount = 3;
        for (let s=0; s<sprayCount; s++){
          const ang = Math.random()*Math.PI*2;
          const rad = size * (0.2 + Math.random()*0.6) * state.scatter * 1.4;
          const sx = x + Math.cos(ang)*rad;
          const sy = y + Math.sin(ang)*rad;
          ctx.globalAlpha = 0.35 + Math.random()*0.25;
          ctx.beginPath();
          ctx.arc(sx, sy, size*(0.12 + Math.random()*0.24), 0, Math.PI*2);
          ctx.fill();
          ctx.globalAlpha = 0.95;
        }
      }

      // sparkles
      if (state.scatter > 0.12 && (i % 2 === 0)){
        const sp = (noise3(x*0.03, y*0.03, tNow*0.003) - 0.5) * 2;
        if (Math.abs(sp) > 0.35){
          const sx = x + (Math.random()-0.5)*size*state.scatter*2;
          const sy = y + (Math.random()-0.5)*size*state.scatter*2;
          ctx.globalAlpha = 0.3;
          ctx.beginPath();
          ctx.arc(sx, sy, size*0.2, 0, Math.PI*2);
          ctx.fill();
          ctx.globalAlpha = 0.95;
        }
      }
    }
    ctx.restore();
  }

  // Auto agents
  function makeAgents(n=6){
    state.agents = [];
    for (let i=0;i<n;i++){
      state.agents.push({
        x: state.cx + (Math.random()-0.5)*state.width*0.4,
        y: state.cy + (Math.random()-0.5)*state.height*0.4,
        vx: 0, vy: 0,
      });
    }
  }
  function stepAgents(dt){
    const t = performance.now();
    const sp = 0.9;
    for (const a of state.agents){
      const f = flowVec(a.x, a.y, t*0.001);
      a.vx = (a.vx + f.x * 0.7)*0.96;
      a.vy = (a.vy + f.y * 0.7)*0.96;
      const old = { x: a.x, y: a.y, t: t - dt };
      a.x += a.vx * sp * dt*0.06;
      a.y += a.vy * sp * dt*0.06;
      bound(a);
      safeSymmetricSegment(old, {x:a.x, y:a.y, t:t});
    }
  }

  // Bounds helpers
  function bound(p){
    const m = state.boundsMode;
    if (m === 'wrap'){
      if (p.x < -20) p.x = state.width+20;
      if (p.x > state.width+20) p.x = -20;
      if (p.y < -20) p.y = state.height+20;
      if (p.y > state.height+20) p.y = -20;
    } else if (m === 'bounce'){
      if (p.x < 0){ p.x = 0; p.vx = -p.vx*0.9; }
      if (p.x > state.width){ p.x = state.width; p.vx = -p.vx*0.9; }
      if (p.y < 0){ p.y = 0; p.vy = -p.vy*0.9; }
      if (p.y > state.height){ p.y = state.height; p.vy = -p.vy*0.9; }
    } else { // clamp
      p.x = clamp(p.x, 0, state.width);
      p.y = clamp(p.y, 0, state.height);
    }
  }

  // Sensor painter (draws without touch when sensor modes enabled)
  function getScreenAngleRad(){
    const o = (screen.orientation && typeof screen.orientation.angle === 'number') ? screen.orientation.angle : (window.orientation || 0);
    return (o % 360) * Math.PI/180;
  }

  function updateSensorPainter(dt){
    if (!state.sensorsEnabled || state.sensorMode === 'off' || !state.sensorDraws) return;

    const now = performance.now();
    const p = state.sensor;
    if (!p.inited){
      p.x = state.cx; p.y = state.cy;
      p.lastX = p.x; p.lastY = p.y;
      p.vx = 0; p.vy = 0;
      p.inited = true;
    }

    const dtSec = Math.max(0.001, dt * 0.001);
    const rotZ = state.rot.alpha || 0; // yaw-like rotation rate (deg/s)
    const ang = -getScreenAngleRad();

    if (state.sensorMode === 'tilt'){
      // Stable tilt mapping (no velocity feedback)
      const reach = 0.46; // fraction of screen
      const tx = state.cx + (state.tiltX * state.width * reach);
      const ty = state.cy + (state.tiltY * state.height * reach);
      // critically-damped smoothing toward target
      const smoothing = 1 - Math.pow(1 - (0.22 + state.sensorInf*0.5), dtSec*60);
      p.x = lerp(p.x, tx, smoothing);
      p.y = lerp(p.y, ty, smoothing);
      // small swirl from flow to keep organic
      const f = flowVec(p.x, p.y, now*0.001);
      p.x += f.x * state.turbInt * 8 * dtSec;
      p.y += f.y * state.turbInt * 8 * dtSec;
    } else if (state.sensorMode === 'motion' || state.sensorMode === 'motion-swirl'){
      // Acceleration-driven velocity
      // choose linear acceleration for stability
      let ax = state.ax, ay = state.ay;
      // rotate device axes to screen coords
      const rx = ax * Math.cos(ang) - ay * Math.sin(ang);
      const ry = ax * Math.sin(ang) + ay * Math.cos(ang);
      const mag = Math.hypot(rx, ry);
      const dz = state.deadzone;
      const gain = 45 * state.motionSens * (0.5 + state.sensorInf);

      const driveX = (mag > dz ? (rx / (mag || 1)) * (mag - dz) : 0) * gain;
      const driveY = (mag > dz ? (ry / (mag || 1)) * (mag - dz) : 0) * gain;

      p.vx += driveX * dtSec;
      p.vy += driveY * dtSec;

      // Flow + optional gyro swirl
      const f = flowVec(p.x, p.y, now*0.001);
      let swirl = 0;
      if (state.sensorMode === 'motion-swirl'){
        swirl = clamp(rotZ/180, -2, 2) * state.sensorInf; // convert deg/s to a small factor
      }
      // apply flow
      p.vx += f.x * state.turbInt * (16 + Math.abs(swirl)*10) * dtSec;
      p.vy += f.y * state.turbInt * (16 + Math.abs(swirl)*10) * dtSec;
      // apply swirl by rotating velocity vector
      if (swirl !== 0){
        const s = Math.sin(swirl * dtSec), c = Math.cos(swirl * dtSec);
        const vx = p.vx*c - p.vy*s;
        const vy = p.vx*s + p.vy*c;
        p.vx = vx; p.vy = vy;
      }

      // friction
      p.vx *= state.friction;
      p.vy *= state.friction;

      // move
      p.x += p.vx;
      p.y += p.vy;

      bound(p);
    } else if (state.sensorMode === 'gyro-orbit'){
      // Orbit center; rotation rate controls angular speed; acceleration controls radius
      const angleSpeed = (rotZ/180) * (0.8 + state.sensorInf*1.6); // rev/sec-ish scaled
      // radius target from acceleration magnitude
      const rMax = Math.min(state.width, state.height)*0.38;
      const rTarget = clamp((state.accelMag - 3)/7, 0, 1) * rMax; // ~3..10 m/s^2
      p._orbitR = lerp(p._orbitR || (rMax*0.25), rTarget, 1 - Math.pow(1-0.25, dtSec*60));
      p._orbitA = (p._orbitA || 0) + angleSpeed * dtSec * Math.PI*2;
      const tx = state.cx + Math.cos(p._orbitA)*p._orbitR;
      const ty = state.cy + Math.sin(p._orbitA)*p._orbitR;
      const smoothing = 1 - Math.pow(1 - 0.28, dtSec*60);
      p.x = lerp(p.x, tx, smoothing);
      p.y = lerp(p.y, ty, smoothing);
    }

    // Compute speed for gating
    const speed = Math.hypot(p.x - p.lastX, p.y - p.lastY) / Math.max(1, dt);
    // Draw if moving enough
    if (speed > state.minDrawSpeed){
      const old = { x: p.lastX, y: p.lastY, t: now - dt };
      const cur = { x: p.x, y: p.y, t: now };
      // teleport guard here too
      const dist = Math.hypot(cur.x-old.x, cur.y-old.y);
      const MAX_SEG = Math.min(state.width, state.height) * 0.35;
      if (dist <= MAX_SEG){
        drawSymmetricSegment(old, cur);
      }
      p.lastX = p.x; p.lastY = p.y;
    } else {
      // update without drawing
      p.lastX = p.x; p.lastY = p.y;
    }
  }

  // Loop
  let lastFrame = performance.now();
  function tick(){
    const now = performance.now();
    let dt = now - lastFrame;
    // Clamp dt to avoid huge teleports after tab switch
    if (dt > 120) dt = 16;
    lastFrame = now;

    // trail fade
    if (state.fade > 0){
      ctx.save();
      ctx.globalCompositeOperation = 'source-over';
      const alpha = clamp(state.fade, 0, 1);
      if (state.bgMode === 'light'){
        ctx.fillStyle = `rgba(250,252,255,${alpha})`;
      } else if (state.bgMode === 'deep'){
        ctx.fillStyle = `rgba(0,0,0,${alpha*0.95})`;
      } else {
        ctx.fillStyle = `rgba(5,5,8,${alpha})`;
      }
      ctx.fillRect(0,0,state.width,state.height);
      ctx.restore();
    }

    // symmetry yaw rotation (use calibrated yawBias)
    state.rotOffset = (state.yaw - state.yawBias) * 0.15 * state.sensorInf;

    // sensor painter
    updateSensorPainter(dt);

    // auto agents
    if (state.auto){
      stepAgents(dt);
    }

    requestAnimationFrame(tick);
  }

  // Sensors
  let orientationListenerAdded = false;
  let motionListenerAdded = false;

  async function enableSensors(){
    try {
      if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function'){
        await DeviceMotionEvent.requestPermission().catch(()=>null);
      }
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
        await DeviceOrientationEvent.requestPermission().catch(()=>null);
      }
    } catch(e){}
    addSensorListeners();
    state.sensorsEnabled = true;
    sensorBtn.classList.add('active');
    sensorBtn.innerHTML = 'üì≥ Sensors On';
  }
  function addSensorListeners(){
    if (!orientationListenerAdded && 'DeviceOrientationEvent' in window){
      window.addEventListener('deviceorientation', onOrientation, { passive: true });
      orientationListenerAdded = true;
    }
    if (!motionListenerAdded && 'DeviceMotionEvent' in window){
      window.addEventListener('devicemotion', onMotion, { passive: true });
      motionListenerAdded = true;
    }
  }

  // Orientation (tilt)
  function onOrientation(e){
    if (!state.sensorsEnabled) return;
    const beta = e.beta ?? 0;   // x tilt (-180,180)
    const gamma = e.gamma ?? 0; // y tilt (-90,90)
    const alpha = e.alpha ?? 0; // yaw
    // Normalize to -1..1
    state.tiltX = clamp(gamma/45, -1, 1);
    state.tiltY = clamp(beta/45, -1, 1);
    state.yaw = alpha/180 - 1;
  }

  // Motion (accel + rotation)
  const lp = { ax:0, ay:0, az:0, gx:0, gy:0, gz:0 }; // low-pass states
  function onMotion(e){
    if (!state.sensorsEnabled) return;
    const inc = e.accelerationIncludingGravity || {x:0,y:0,z:0};
    const lin = e.acceleration || null; // often null on iOS
    const r = e.rotationRate || { alpha:0, beta:0, gamma:0 };

    // Low-pass gravity estimate from including-gravity accel
    const a = clamp(state.filterStrength, 0, 0.95);
    lp.gx = a*lp.gx + (1-a)*(inc.x || 0);
    lp.gy = a*lp.gy + (1-a)*(inc.y || 0);
    lp.gz = a*lp.gz + (1-a)*(inc.z || 0);

    // Linear acceleration: prefer OS-provided, else subtract gravity estimate
    const lax = (lin && isFinite(lin.x)) ? lin.x : (inc.x - lp.gx);
    const lay = (lin && isFinite(lin.y)) ? lin.y : (inc.y - lp.gy);
    const laz = (lin && isFinite(lin.z)) ? lin.z : (inc.z - lp.gz);

    // Low-pass linear accel for stability
    lp.ax = a*lp.ax + (1-a)*(lax);
    lp.ay = a*lp.ay + (1-a)*(lay);
    lp.az = a*lp.az + (1-a)*(laz);

    // Choose data: linear (preferred) or including gravity if toggle off
    const useLin = state.useLinear;
    state.ax = useLin ? lp.ax : lp.gx;
    state.ay = useLin ? lp.ay : lp.gy;
    state.az = useLin ? lp.az : lp.gz;

    const ai = e.accelerationIncludingGravity || {x:0,y:0,z:0};
    state.accelMag = Math.sqrt((ai.x||0)**2 + (ai.y||0)**2 + (ai.z||0)**2);
    state.rot = { alpha: r.alpha||0, beta: r.beta||0, gamma: r.gamma||0 };
    state.rotMag = Math.sqrt((state.rot.alpha)**2 + (state.rot.beta)**2 + (state.rot.gamma)**2);
  }

  // Controls/UI
  const panel = document.getElementById('panel');
  const menuBtn = document.getElementById('menuBtn');
  const saveBtn = document.getElementById('saveBtn');
  const clearBtn = document.getElementById('clearBtn');
  const autoBtn = document.getElementById('autoBtn');
  const sensorBtn = document.getElementById('sensorBtn');
  const hint = document.getElementById('hint');

  const paletteEl = document.getElementById('palette');
  const colorSpeed = document.getElementById('colorSpeed');
  const colorSpeedVal = document.getElementById('colorSpeedVal');
  const size = document.getElementById('size');
  const sizeVal = document.getElementById('sizeVal');
  const glow = document.getElementById('glow');
  const glowVal = document.getElementById('glowVal');
  const sym = document.getElementById('sym');
  const symVal = document.getElementById('symVal');
  const mirror = document.getElementById('mirror');
  const kaleido = document.getElementById('kaleido');
  const fade = document.getElementById('fade');
  const fadeVal = document.getElementById('fadeVal');
  const scatter = document.getElementById('scatter');
  const scatterVal = document.getElementById('scatterVal');

  const turbMode = document.getElementById('turbMode');
  const turbInt = document.getElementById('turbInt');
  const turbIntVal = document.getElementById('turbIntVal');
  const turbScale = document.getElementById('turbScale');
  const turbScaleVal = document.getElementById('turbScaleVal');
  const turbSpeed = document.getElementById('turbSpeed');
  const turbSpeedVal = document.getElementById('turbSpeedVal');

  const sensorMode = document.getElementById('sensorMode');
  const sensorInf = document.getElementById('sensorInf');
  const sensorInfVal = document.getElementById('sensorInfVal');
  const motionSens = document.getElementById('motionSens');
  const motionSensVal = document.getElementById('motionSensVal');
  const friction = document.getElementById('friction');
  const frictionVal = document.getElementById('frictionVal');
  const deadzone = document.getElementById('deadzone');
  const deadzoneVal = document.getElementById('deadzoneVal');
  const minDraw = document.getElementById('minDraw');
  const minDrawVal = document.getElementById('minDrawVal');
  const filter = document.getElementById('filter');
  const filterVal = document.getElementById('filterVal');
  const boundsMode = document.getElementById('boundsMode');
  const useLinear = document.getElementById('useLinear');
  const shakeClear = document.getElementById('shakeClear');
  const sensorDraw = document.getElementById('sensorDraw');
  const calibrate = document.getElementById('calibrate');
  const center = document.getElementById('center');

  const bgMode = document.getElementById('bgMode');
  const composite = document.getElementById('composite');
  const randomize = document.getElementById('randomize');

  const quality = document.getElementById('quality');
  const resetView = document.getElementById('resetView');

  const brushSoft = document.getElementById('brushSoft');
  const brushSpray = document.getElementById('brushSpray');

  menuBtn.addEventListener('click', () => panel.classList.toggle('hidden'));

  saveBtn.addEventListener('click', () => {
    try {
      const url = canvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = url;
      a.download = `psychedelic-${Date.now()}.png`;
      document.body.appendChild(a);
      a.click();
      a.remove();
    } catch (e){
      window.open(canvas.toDataURL('image/png'), '_blank');
    }
  });

  clearBtn.addEventListener('click', () => paintBackground(true));

  autoBtn.addEventListener('click', () => {
    state.auto = !state.auto;
    autoBtn.textContent = state.auto ? 'Auto (On)' : 'Auto';
    if (state.auto && state.agents.length === 0) makeAgents(6);
  });

  sensorBtn.addEventListener('click', () => {
    if (!state.sensorsEnabled) {
      enableSensors();
    } else {
      state.sensorsEnabled = false;
      state.sensorMode = 'off';
      sensorMode.value = 'off';
      sensorBtn.classList.remove('active');
      sensorBtn.innerHTML = 'üì≥ Sensors';
    }
  });

  // Brush toggle
  function setBrush(name){
    state.brush = name;
    brushSoft.classList.toggle('active', name==='soft');
    brushSpray.classList.toggle('active', name==='spray');
  }
  brushSoft.addEventListener('click', ()=>setBrush('soft'));
  brushSpray.addEventListener('click', ()=>setBrush('spray'));

  // Wiring
  paletteEl.addEventListener('change', e => state.palette = e.target.value);
  colorSpeed.addEventListener('input', e => { state.colorSpeed = +e.target.value; colorSpeedVal.textContent = state.colorSpeed.toFixed(2); });
  size.addEventListener('input', e => { state.brushSize = +e.target.value; sizeVal.textContent = state.brushSize|0; });
  glow.addEventListener('input', e => { state.glow = +e.target.value; glowVal.textContent = state.glow|0; });
  sym.addEventListener('input', e => { state.symmetry = parseInt(e.target.value,10); symVal.textContent = state.symmetry; });
  mirror.addEventListener('click', () => { state.mirror = !state.mirror; mirror.classList.toggle('active', state.mirror); });
  kaleido.addEventListener('click', () => { state.kaleido = !state.kaleido; kaleido.classList.toggle('active', state.kaleido); });
  fade.addEventListener('input', e => { state.fade = +e.target.value; fadeVal.textContent = state.fade.toFixed(3); });
  scatter.addEventListener('input', e => { state.scatter = +e.target.value; scatterVal.textContent = state.scatter.toFixed(2); });

  turbMode.addEventListener('change', e => state.turbMode = e.target.value);
  turbInt.addEventListener('input', e => { state.turbInt = +e.target.value; turbIntVal.textContent = state.turbInt.toFixed(2); });
  turbScale.addEventListener('input', e => { state.turbScale = +e.target.value; turbScaleVal.textContent = state.turbScale.toFixed(3); });
  turbSpeed.addEventListener('input', e => { state.turbSpeed = +e.target.value; turbSpeedVal.textContent = state.turbSpeed.toFixed(2); });

  sensorMode.addEventListener('change', e => {
    state.sensorMode = e.target.value;
    state.sensor.inited = false; // re-center painter on mode change
    if (state.sensorMode !== 'off' && !state.sensorsEnabled) enableSensors();
  });
  sensorInf.addEventListener('input', e => { state.sensorInf = +e.target.value; sensorInfVal.textContent = state.sensorInf.toFixed(2); });
  motionSens.addEventListener('input', e => { state.motionSens = +e.target.value; motionSensVal.textContent = state.motionSens.toFixed(2); });
  friction.addEventListener('input', e => { state.friction = +e.target.value; frictionVal.textContent = state.friction.toFixed(2); });
  deadzone.addEventListener('input', e => { state.deadzone = +e.target.value; deadzoneVal.textContent = state.deadzone.toFixed(2); });
  minDraw.addEventListener('input', e => { state.minDrawSpeed = +e.target.value; minDrawVal.textContent = state.minDrawSpeed.toFixed(2); });
  filter.addEventListener('input', e => { state.filterStrength = +e.target.value; filterVal.textContent = state.filterStrength.toFixed(2); });
  boundsMode.addEventListener('change', e => state.boundsMode = e.target.value);
  useLinear.addEventListener('click', () => {
    state.useLinear = !state.useLinear;
    useLinear.classList.toggle('active', state.useLinear);
  });
  shakeClear.addEventListener('click', () => {
    state.shakeClears = !state.shakeClears;
    shakeClear.classList.toggle('active', state.shakeClears);
  });
  sensorDraw.addEventListener('click', () => {
    state.sensorDraws = !state.sensorDraws;
    sensorDraw.classList.toggle('active', state.sensorDraws);
  });
  calibrate.addEventListener('click', () => {
    state.yawBias = state.yaw;
    // also zero tilt baseline
    state._tiltBiasX = state.tiltX;
    state._tiltBiasY = state.tiltY;
  });
  center.addEventListener('click', () => {
    state.sensor.inited = false;
  });

  bgMode.addEventListener('change', e => { state.bgMode = e.target.value; paintBackground(true); });

  composite.addEventListener('click', () => {
    state.composite = (state.composite === 'lighter') ? 'source-over' : 'lighter';
    composite.textContent = (state.composite === 'lighter') ? 'Additive' : 'Normal';
    composite.classList.toggle('active', state.composite === 'lighter');
  });

  randomize.addEventListener('click', () => {
    state.colorOffset = Math.random()*360;
    state.brushSize = Math.floor(10 + Math.random()*80);
    size.value = state.brushSize; sizeVal.textContent = state.brushSize;
    state.glow = Math.floor(Math.random()*60);
    glow.value = state.glow; glowVal.textContent = state.glow;
    state.scatter = +(Math.random().toFixed(2));
    scatter.value = state.scatter; scatterVal.textContent = state.scatter.toFixed(2);
    state.symmetry = Math.floor(1 + Math.random()*18);
    sym.value = state.symmetry; symVal.textContent = state.symmetry;
    state.palette = ['Rainbow','Neon','Sunset','Ocean','Acid'][Math.floor(Math.random()*5)];
    paletteEl.value = state.palette;
    state.turbMode = Math.random() > 0.5 ? 'curl' : 'noise';
    turbMode.value = state.turbMode;
    state.turbInt = +(Math.random()*1.1).toFixed(2);
    turbInt.value = state.turbInt; turbIntVal.textContent = state.turbInt.toFixed(2);
    state.turbScale = +(0.002 + Math.random()*0.02).toFixed(3);
    turbScale.value = state.turbScale; turbScaleVal.textContent = state.turbScale.toFixed(3);
    state.turbSpeed = +(Math.random()*1.2).toFixed(2);
    turbSpeed.value = state.turbSpeed; turbSpeedVal.textContent = state.turbSpeed.toFixed(2);
  });

  quality.addEventListener('change', e => {
    state.quality = e.target.value;
    if (state.quality === 'performance') {
      DPR_MAX = 1;
      state.glow = Math.min(state.glow, 18);
      glow.value = state.glow; glowVal.textContent = state.glow|0;
    } else if (state.quality === 'high') {
      DPR_MAX = 2.5;
    } else {
      DPR_MAX = 2;
    }
    resize(true);
  });

  resetView.addEventListener('click', () => {
    state.colorOffset = Math.random()*360;
    state.rotOffset = 0;
    paintBackground(true);
  });

  // Init labels and UI
  function syncLabels(){
    colorSpeedVal.textContent = state.colorSpeed.toFixed(2);
    sizeVal.textContent = state.brushSize|0;
    glowVal.textContent = state.glow|0;
    symVal.textContent = state.symmetry;
    fadeVal.textContent = state.fade.toFixed(3);
    scatterVal.textContent = state.scatter.toFixed(2);
    turbIntVal.textContent = state.turbInt.toFixed(2);
    turbScaleVal.textContent = state.turbScale.toFixed(3);
    turbSpeedVal.textContent = state.turbSpeed.toFixed(2);
    sensorInfVal.textContent = state.sensorInf.toFixed(2);
    motionSensVal.textContent = state.motionSens.toFixed(2);
    frictionVal.textContent = state.friction.toFixed(2);
    deadzoneVal.textContent = state.deadzone.toFixed(2);
    minDrawVal.textContent = state.minDrawSpeed.toFixed(2);
    filterVal.textContent = state.filterStrength.toFixed(2);
  }

  // Shake-to-clear via accel magnitude threshold
  let lastShakeTime = 0;
  window.addEventListener('devicemotion', (e) => {
    if (!state.shakeClears) return;
    const ai = e.accelerationIncludingGravity || {x:0,y:0,z:0};
    const mag = Math.sqrt((ai.x||0)**2 + (ai.y||0)**2 + (ai.z||0)**2);
    if (mag > 22){
      const t = performance.now();
      if (t - lastShakeTime > 800){
        lastShakeTime = t;
        paintBackground(true);
        navigator.vibrate?.(50);
      }
    }
  }, { passive: true });

  // Hide hint after first action
  let hinted = false;
  function hideHint(){
    if (hinted) return;
    hinted = true;
    hint.style.opacity = '0';
    setTimeout(()=> hint.style.display='none', 400);
  }
  canvas.addEventListener('pointerdown', hideHint, { passive: true });
  sensorBtn.addEventListener('click', hideHint);

  // Kickoff
  resize();
  syncLabels();
  paintBackground(true);
  makeAgents(6);
  requestAnimationFrame(tick);

  // Prevent iOS double-tap zoom
  let lastTouch = 0;
  document.addEventListener('touchend', function(e){
    const t = Date.now();
    if (t - lastTouch < 300) e.preventDefault();
    lastTouch = t;
  }, {passive:false});

})();
</script>
</body>
</html>
```

What changed
- Motion modes revamped:
  - Motion (inertial): linear acceleration drives velocity with deadzone, friction, sensitivity.
  - Motion + Gyro swirl: same as above, plus rotation-rate swirls velocity for wilder paths.
  - Gyro orbit: rotation spins a brush around center; acceleration changes radius.
  - Tilt (stable): no feedback loop; maps tilt directly to position with smooth damping.
- Sensor options:
  - Sensitivity, friction, deadzone, min draw speed, filter strength (LPF), bounds (wrap/bounce/clamp), linear-acc toggle, calibrate yaw/tilt, center brush, sensor draw toggle.
- Teleport guard: large distance or long time gaps are treated as teleports (no stroke), eliminating random long lines.
- General: still supports symmetry, kaleidoscope, turbulence (noise/curl), Auto agents, saving, hints, and quality scaling.

If you want me to add a ‚Äúrecord GIF‚Äù mode or a shader-based bloom/turbulence WebGL version, I can spin that up next.
